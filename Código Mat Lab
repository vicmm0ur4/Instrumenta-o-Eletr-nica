clear all
clc
% clear instrfindall % Geralmente nÃ£o Ã© necessÃ¡rio, mas pode ser Ãºtil se tiver problemas persistentes

% === CONFIGURAÃ‡ÃƒO SERIAL ===
portaSerial = "COM9"; % << ALTERE PARA SUA PORTA
baudrate = 9600;
try
    s = serialport(portaSerial, baudrate);
    configureTerminator(s, "LF");
    s.Timeout = 1; % Define um timeout para a leitura, evita travar o script
    disp(['ðŸ“¡ Porta serial ', portaSerial, ' aberta com sucesso!']);
catch ME
    error(['Erro ao abrir a porta serial: ', ME.message, ...
           '\nVerifique a porta, conexÃ£o e se nÃ£o estÃ¡ em uso por outro programa.']);
end

% === VARIÃVEIS GLOBAIS ===
% PrÃ©-alocaÃ§Ã£o para melhor performance (ajuste o tamanho inicial conforme necessÃ¡rio)
preAllocSize = 1000; % Por exemplo, para 1000 pontos
tempo = zeros(1, preAllocSize);
rpmRaw = zeros(1, preAllocSize); % Para guardar os valores brutos de RPM
ax = zeros(1, preAllocSize);
ay = zeros(1, preAllocSize);
az = zeros(1, preAllocSize);
dataIdx = 0; % Ãndice para preencher os arrays

tempoInicial = datetime('now');

% --- ParÃ¢metros de Filtro de MÃ©dia MÃ³vel ---
% Aumentar o windowSize para mais suavidade, mas pode aumentar o atraso.
% Um valor entre 20-50 pode ser um bom ponto de partida.
windowSize = 30; % Aumentado para mais suavidade. Experimente valores entre 20 e 50.
tempoDescarte = 2; % Tempo para iniciar a leitura real (Ãºtil para estabilizar)

% === VARIÃVEIS DE PICO ===
assignin('base', 'picoGlobal', struct('aMax', 0, 'rpmPico', 0));

% === INTERFACE ===
f = figure('Name', 'Monitor de VibraÃ§Ã£o e RotaÃ§Ã£o - Viga Engastada', 'DeleteFcn', @(,) closeSerialPort(s)); % Adiciona fechamento da serial ao fechar a figura
tiledlayout(2,1);

% --- GrÃ¡fico de AceleraÃ§Ã£o ---
axPlot = nexttile;
hold on;
hAX = animatedline('Color', 'r', 'DisplayName', 'Acel X');
hAY = animatedline('Color', 'g', 'DisplayName', 'Acel Y');
hAZ = animatedline('Color', 'b', 'DisplayName', 'Acel Z');
title('VibraÃ§Ã£o (aceleraÃ§Ã£o)');
ylabel('AceleraÃ§Ã£o [g]');
legend('Location', 'northwest'); % PosiÃ§Ã£o da legenda
grid on;
yMaxAcelerometro = 0;

% --- GrÃ¡fico de RotaÃ§Ã£o ---
rpsPlot = nexttile;
hRPM = animatedline('Color', 'k', 'LineWidth', 1.5);
title('RotaÃ§Ã£o do motor (RPM - suavizado)');
ylabel('RPM');
xlabel('Tempo (s)');
grid on;
ylim(rpsPlot, [0 3600]); % Mantenha o limite para nÃ£o ficar auto-escalando toda hora

% ExibiÃ§Ã£o numÃ©rica
txtRPM = annotation('textbox', [0.78 0.15 0.1 0.05], ...
    'String', '', 'EdgeColor', 'none', 'FontSize', 12, 'FontWeight', 'bold');

txtPico = annotation('textbox', [0.15 0.53 0.3 0.05], ...
    'String', '', 'EdgeColor', 'none', 'FontSize', 12, 'FontWeight', 'bold');

% BotÃ£o de reset do pico
btn = uicontrol('Style', 'pushbutton', 'String', 'Reset Pico', ...
    'Position', [20 20 100 30], ...
    'Callback', @(src, event) resetarPico(txtPico));

% === LOOP DE LEITURA ===
disp('ðŸš€ Monitoramento iniciado. Aguardando dados...');
picoHabilitado = false;

try
    while ishandle(f) % Garante que o loop pare se a figura for fechada
        if s.NumBytesAvailable > 0
            linha = readline(s);
            dados = sscanf(linha, '%f,%f,%f,%f');

            if length(dados) == 4
                rpsVal = dados(1);
                axVal = dados(2);
                ayVal = dados(3);
                azVal = dados(4);
                
                t = datetime('now') - tempoInicial;
                seg = seconds(t);
                rpmVal = rpsVal * 60;

                % --- Armazenamento de dados ---
                dataIdx = dataIdx + 1;
                % Expande os arrays se necessÃ¡rio (para evitar erro de Ã­ndice)
                if dataIdx > length(tempo)
                    tempo = [tempo, zeros(1, preAllocSize)];
                    rpmRaw = [rpmRaw, zeros(1, preAllocSize)];
                    ax = [ax, zeros(1, preAllocSize)];
                    ay = [ay, zeros(1, preAllocSize)];
                    az = [az, zeros(1, preAllocSize)];
                end
                
                tempo(dataIdx) = seg;
                rpmRaw(dataIdx) = rpmVal; % Armazena o RPM bruto
                ax(dataIdx) = axVal;
                ay(dataIdx) = ayVal;
                az(dataIdx) = azVal;

                % --- MÃ©dia MÃ³vel OTIMIZADA ---
                % Usamos apenas os dados relevantes para a mÃ©dia
                if dataIdx >= windowSize
                    % Calcula a mÃ©dia dos Ãºltimos 'windowSize' pontos
                    rpmSuave = mean(rpmRaw(dataIdx - windowSize + 1:dataIdx));
                else
                    % Enquanto nÃ£o hÃ¡ dados suficientes, usa a mÃ©dia dos dados disponÃ­veis
                    rpmSuave = mean(rpmRaw(1:dataIdx));
                end

                addpoints(hRPM, seg, rpmSuave);
                xlim(rpsPlot, [max(0, seg - 10), seg]); % Exibe os Ãºltimos 10s
                txtRPM.String = sprintf('RPM: %.0f', rpmSuave);

                % Habilita pico apÃ³s tempo de descarte
                if rpmSuave > 0 && seg > tempoDescarte
                    picoHabilitado = true;
                end

                if picoHabilitado
                    % Plotar aceleraÃ§Ã£o
                    addpoints(hAX, seg, axVal);
                    addpoints(hAY, seg, ayVal);
                    addpoints(hAZ, seg, azVal);
                    xlim(axPlot, [max(0, seg - 10), seg]);

                    % Auto-escala Y da aceleraÃ§Ã£o de forma inteligente
                    currentMaxAbsAcel = max([abs(axVal), abs(ayVal), abs(azVal)]);
                    if currentMaxAbsAcel > yMaxAcelerometro
                        yMaxAcelerometro = currentMaxAbsAcel + 0.1; % Pequena margem
                        ylim(axPlot, [-yMaxAcelerometro yMaxAcelerometro]);
                    elseif currentMaxAbsAcel < (yMaxAcelerometro * 0.7) && yMaxAcelerometro > 1 % Reajusta se cair muito
                        yMaxAcelerometro = currentMaxAbsAcel + 0.1;
                        if yMaxAcelerometro < 0.5 % Evita auto-escala para valores muito pequenos
                            yMaxAcelerometro = 0.5;
                        end
                         ylim(axPlot, [-yMaxAcelerometro yMaxAcelerometro]);
                    end


                    % Calcular mÃ³dulo da aceleraÃ§Ã£o
                    moduloAcel = sqrt(axVal^2 + ayVal^2 + azVal^2);

                    picoData = evalin('base', 'picoGlobal');
                    if moduloAcel > picoData.aMax
                        picoData.aMax = moduloAcel;
                        picoData.rpmPico = rpmSuave;
                        assignin('base', 'picoGlobal', picoData);
                        txtPico.String = sprintf('ðŸ“ˆ Pico: %.2f g @ %.0f RPM', ...
                            picoData.aMax, picoData.rpmPico);
                    end
                end

                % Atualiza os grÃ¡ficos na tela. 'limitrate' Ã© crucial.
                drawnow limitrate;
            end
        else
            % Pequena pausa para nÃ£o consumir 100% da CPU esperando dados
            pause(0.001);
        end
    end
catch ME
    warning("ðŸ›‘ Monitoramento interrompido. Erro: %s", ME.message);
end

% === FunÃ§Ãµes Auxiliares ===

% FunÃ§Ã£o para fechar a porta serial quando a figura Ã© fechada
function closeSerialPort(s)
    if isa(s, 'serialport') && isvalid(s)
        fclose(s); % Note: serialport objects do not have fclose, use delete(s)
        delete(s); % Use delete para fechar e limpar o objeto serialport
        disp('Porta serial fechada.');
    end
end

% FunÃ§Ã£o de Reset do Pico
function resetarPico(txtPico)
    picoData.aMax = 0;
    picoData.rpmPico = 0;
    assignin('base', 'picoGlobal', picoData);
    txtPico.String = 'ðŸ“ˆ Pico: 0.00 g @ 0 RPM';
end

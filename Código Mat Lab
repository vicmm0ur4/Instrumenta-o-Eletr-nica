clear all
clc
% clear instrfindall % Geralmente não é necessário, mas pode ser útil se tiver problemas persistentes

% === CONFIGURAÇÃO SERIAL ===
portaSerial = "COM9"; % << ALTERE PARA SUA PORTA
baudrate = 9600;
try
    s = serialport(portaSerial, baudrate);
    configureTerminator(s, "LF");
    s.Timeout = 1; % Define um timeout para a leitura, evita travar o script
    disp(['📡 Porta serial ', portaSerial, ' aberta com sucesso!']);
catch ME
    error(['Erro ao abrir a porta serial: ', ME.message, ...
           '\nVerifique a porta, conexão e se não está em uso por outro programa.']);
end

% === VARIÁVEIS GLOBAIS ===
% Pré-alocação para melhor performance (ajuste o tamanho inicial conforme necessário)
preAllocSize = 1000; % Por exemplo, para 1000 pontos
tempo = zeros(1, preAllocSize);
rpmRaw = zeros(1, preAllocSize); % Para guardar os valores brutos de RPM
ax = zeros(1, preAllocSize);
ay = zeros(1, preAllocSize);
az = zeros(1, preAllocSize);
dataIdx = 0; % Índice para preencher os arrays

tempoInicial = datetime('now');

% --- Parâmetros de Filtro de Média Móvel ---
% Aumentar o windowSize para mais suavidade, mas pode aumentar o atraso.
% Um valor entre 20-50 pode ser um bom ponto de partida.
windowSize = 30; % Aumentado para mais suavidade. Experimente valores entre 20 e 50.
tempoDescarte = 2; % Tempo para iniciar a leitura real (útil para estabilizar)

% === VARIÁVEIS DE PICO ===
assignin('base', 'picoGlobal', struct('aMax', 0, 'rpmPico', 0));

% === INTERFACE ===
f = figure('Name', 'Monitor de Vibração e Rotação - Viga Engastada', 'DeleteFcn', @(,) closeSerialPort(s)); % Adiciona fechamento da serial ao fechar a figura
tiledlayout(2,1);

% --- Gráfico de Aceleração ---
axPlot = nexttile;
hold on;
hAX = animatedline('Color', 'r', 'DisplayName', 'Acel X');
hAY = animatedline('Color', 'g', 'DisplayName', 'Acel Y');
hAZ = animatedline('Color', 'b', 'DisplayName', 'Acel Z');
title('Vibração (aceleração)');
ylabel('Aceleração [g]');
legend('Location', 'northwest'); % Posição da legenda
grid on;
yMaxAcelerometro = 0;

% --- Gráfico de Rotação ---
rpsPlot = nexttile;
hRPM = animatedline('Color', 'k', 'LineWidth', 1.5);
title('Rotação do motor (RPM - suavizado)');
ylabel('RPM');
xlabel('Tempo (s)');
grid on;
ylim(rpsPlot, [0 3600]); % Mantenha o limite para não ficar auto-escalando toda hora

% Exibição numérica
txtRPM = annotation('textbox', [0.78 0.15 0.1 0.05], ...
    'String', '', 'EdgeColor', 'none', 'FontSize', 12, 'FontWeight', 'bold');

txtPico = annotation('textbox', [0.15 0.53 0.3 0.05], ...
    'String', '', 'EdgeColor', 'none', 'FontSize', 12, 'FontWeight', 'bold');

% Botão de reset do pico
btn = uicontrol('Style', 'pushbutton', 'String', 'Reset Pico', ...
    'Position', [20 20 100 30], ...
    'Callback', @(src, event) resetarPico(txtPico));

% === LOOP DE LEITURA ===
disp('🚀 Monitoramento iniciado. Aguardando dados...');
picoHabilitado = false;

try
    while ishandle(f) % Garante que o loop pare se a figura for fechada
        if s.NumBytesAvailable > 0
            linha = readline(s);
            dados = sscanf(linha, '%f,%f,%f,%f');

            if length(dados) == 4
                rpsVal = dados(1);
                axVal = dados(2);
                ayVal = dados(3);
                azVal = dados(4);
                
                t = datetime('now') - tempoInicial;
                seg = seconds(t);
                rpmVal = rpsVal * 60;

                % --- Armazenamento de dados ---
                dataIdx = dataIdx + 1;
                % Expande os arrays se necessário (para evitar erro de índice)
                if dataIdx > length(tempo)
                    tempo = [tempo, zeros(1, preAllocSize)];
                    rpmRaw = [rpmRaw, zeros(1, preAllocSize)];
                    ax = [ax, zeros(1, preAllocSize)];
                    ay = [ay, zeros(1, preAllocSize)];
                    az = [az, zeros(1, preAllocSize)];
                end
                
                tempo(dataIdx) = seg;
                rpmRaw(dataIdx) = rpmVal; % Armazena o RPM bruto
                ax(dataIdx) = axVal;
                ay(dataIdx) = ayVal;
                az(dataIdx) = azVal;

                % --- Média Móvel OTIMIZADA ---
                % Usamos apenas os dados relevantes para a média
                if dataIdx >= windowSize
                    % Calcula a média dos últimos 'windowSize' pontos
                    rpmSuave = mean(rpmRaw(dataIdx - windowSize + 1:dataIdx));
                else
                    % Enquanto não há dados suficientes, usa a média dos dados disponíveis
                    rpmSuave = mean(rpmRaw(1:dataIdx));
                end

                addpoints(hRPM, seg, rpmSuave);
                xlim(rpsPlot, [max(0, seg - 10), seg]); % Exibe os últimos 10s
                txtRPM.String = sprintf('RPM: %.0f', rpmSuave);

                % Habilita pico após tempo de descarte
                if rpmSuave > 0 && seg > tempoDescarte
                    picoHabilitado = true;
                end

                if picoHabilitado
                    % Plotar aceleração
                    addpoints(hAX, seg, axVal);
                    addpoints(hAY, seg, ayVal);
                    addpoints(hAZ, seg, azVal);
                    xlim(axPlot, [max(0, seg - 10), seg]);

                    % Auto-escala Y da aceleração de forma inteligente
                    currentMaxAbsAcel = max([abs(axVal), abs(ayVal), abs(azVal)]);
                    if currentMaxAbsAcel > yMaxAcelerometro
                        yMaxAcelerometro = currentMaxAbsAcel + 0.1; % Pequena margem
                        ylim(axPlot, [-yMaxAcelerometro yMaxAcelerometro]);
                    elseif currentMaxAbsAcel < (yMaxAcelerometro * 0.7) && yMaxAcelerometro > 1 % Reajusta se cair muito
                        yMaxAcelerometro = currentMaxAbsAcel + 0.1;
                        if yMaxAcelerometro < 0.5 % Evita auto-escala para valores muito pequenos
                            yMaxAcelerometro = 0.5;
                        end
                         ylim(axPlot, [-yMaxAcelerometro yMaxAcelerometro]);
                    end


                    % Calcular módulo da aceleração
                    moduloAcel = sqrt(axVal^2 + ayVal^2 + azVal^2);

                    picoData = evalin('base', 'picoGlobal');
                    if moduloAcel > picoData.aMax
                        picoData.aMax = moduloAcel;
                        picoData.rpmPico = rpmSuave;
                        assignin('base', 'picoGlobal', picoData);
                        txtPico.String = sprintf('📈 Pico: %.2f g @ %.0f RPM', ...
                            picoData.aMax, picoData.rpmPico);
                    end
                end

                % Atualiza os gráficos na tela. 'limitrate' é crucial.
                drawnow limitrate;
            end
        else
            % Pequena pausa para não consumir 100% da CPU esperando dados
            pause(0.001);
        end
    end
catch ME
    warning("🛑 Monitoramento interrompido. Erro: %s", ME.message);
end

% === Funções Auxiliares ===

% Função para fechar a porta serial quando a figura é fechada
function closeSerialPort(s)
    if isa(s, 'serialport') && isvalid(s)
        fclose(s); % Note: serialport objects do not have fclose, use delete(s)
        delete(s); % Use delete para fechar e limpar o objeto serialport
        disp('Porta serial fechada.');
    end
end

% Função de Reset do Pico
function resetarPico(txtPico)
    picoData.aMax = 0;
    picoData.rpmPico = 0;
    assignin('base', 'picoGlobal', picoData);
    txtPico.String = '📈 Pico: 0.00 g @ 0 RPM';
end
